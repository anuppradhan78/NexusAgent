"""
Integration tests for history and reports endpoints

Tests the endpoints with actual data flow to ensure they work correctly
in a realistic scenario.

Requirements: 12.3, 12.5
"""
import pytest
from pathlib import Path
import tempfile
import shutil
from fastapi.testclient import TestClient
import time

# Import the app
import sys
sys.path.insert(0, str(Path(__file__).parent.parent))

from main import app, Config


@pytest.fixture
def client():
    """Create test client"""
    return TestClient(app)


@pytest.fixture
def temp_reports_dir():
    """Create temporary reports directory with sample reports"""
    temp_dir = tempfile.mkdtemp()
    
    # Create sample reports
    reports = [
        {
            "filename": "research_report_2025-11-22_10-00-00.md",
            "query": "AI trends in 2025",
            "confidence": 0.85
        },
        {
            "filename": "research_report_2025-11-22_11-00-00.md",
            "query": "Machine learning applications",
            "confidence": 0.92
        },
        {
            "filename": "research_report_2025-11-22_12-00-00.md",
            "query": "Natural language processing advances",
            "confidence": 0.78
        }
    ]
    
    for report in reports:
        content = f"""# Research Report: {report['query']}

**Generated:** 2025-11-22 10:00:00  
**Report ID:** report_{report['filename'].replace('research_report_', '').replace('.md', '')}  
**Query ID:** test-query-id  
**Confidence Score:** {report['confidence']}  
**Processing Time:** 1000ms

---

## Executive Summary

This is a test report for {report['query']}.

## Key Findings

- Finding 1
- Finding 2

## Detailed Analysis

Test analysis content.

---

*Generated by Adaptive Research Agent*
"""
        report_path = Path(temp_dir) / report['filename']
        report_path.write_text(content, encoding='utf-8')
    
    yield temp_dir
    shutil.rmtree(temp_dir)


def test_full_workflow_history_and_reports(client, temp_reports_dir):
    """
    Test complete workflow:
    1. List reports
    2. Get specific report
    3. Check history
    """
    # Override reports directory
    original_dir = Config.REPORT_OUTPUT_DIR
    Config.REPORT_OUTPUT_DIR = temp_reports_dir
    
    try:
        # Step 1: List all reports
        print("\n--- Step 1: List Reports ---")
        response = client.get("/api/reports")
        assert response.status_code == 200
        
        reports_data = response.json()
        assert reports_data["total"] == 3
        assert len(reports_data["reports"]) == 3
        
        print(f"Found {reports_data['total']} reports")
        
        # Verify reports are sorted by timestamp (newest first)
        timestamps = [r["timestamp"] for r in reports_data["reports"]]
        assert timestamps == sorted(timestamps, reverse=True)
        
        # Step 2: Get specific report
        print("\n--- Step 2: Get Specific Report ---")
        first_report_id = reports_data["reports"][0]["report_id"]
        print(f"Fetching report: {first_report_id}")
        
        response = client.get(f"/api/reports/{first_report_id}")
        assert response.status_code == 200
        
        report_data = response.json()
        assert report_data["report_id"] == first_report_id
        assert "content" in report_data
        assert len(report_data["content"]) > 0
        
        # Verify content matches expected format
        assert "# Research Report:" in report_data["content"]
        assert "Executive Summary" in report_data["content"]
        assert "Key Findings" in report_data["content"]
        
        print(f"Successfully retrieved report with {len(report_data['content'])} characters")
        
        # Step 3: Check history (may be empty if no queries were made)
        print("\n--- Step 3: Check History ---")
        response = client.get("/api/research/history")
        
        # Should succeed even if empty
        if response.status_code == 200:
            history_data = response.json()
            print(f"History contains {history_data['total']} queries")
            assert "queries" in history_data
        else:
            # Memory store might not be initialized in test environment
            assert response.status_code == 503
            print("Memory store not available in test environment")
        
    finally:
        Config.REPORT_OUTPUT_DIR = original_dir


def test_reports_pagination(client, temp_reports_dir):
    """Test pagination with reports list"""
    original_dir = Config.REPORT_OUTPUT_DIR
    Config.REPORT_OUTPUT_DIR = temp_reports_dir
    
    try:
        # Get first 2 reports
        response = client.get("/api/reports?limit=2")
        assert response.status_code == 200
        
        data = response.json()
        assert data["total"] == 3
        assert len(data["reports"]) == 2
        
        # Get all reports
        response = client.get("/api/reports?limit=10")
        assert response.status_code == 200
        
        data = response.json()
        assert data["total"] == 3
        assert len(data["reports"]) == 3
        
    finally:
        Config.REPORT_OUTPUT_DIR = original_dir


def test_report_metadata_accuracy(client, temp_reports_dir):
    """Test that report metadata is accurately extracted"""
    original_dir = Config.REPORT_OUTPUT_DIR
    Config.REPORT_OUTPUT_DIR = temp_reports_dir
    
    try:
        # List reports
        response = client.get("/api/reports")
        assert response.status_code == 200
        
        reports = response.json()["reports"]
        
        # Check each report's metadata
        for report in reports:
            # Get full report
            response = client.get(f"/api/reports/{report['report_id']}")
            assert response.status_code == 200
            
            full_report = response.json()
            
            # Verify metadata matches
            assert full_report["metadata"]["report_id"] == report["report_id"]
            assert full_report["metadata"]["filename"] == report["filename"]
            assert full_report["metadata"]["confidence_score"] == report["confidence_score"]
            
            # Verify query is extracted correctly
            assert len(full_report["metadata"]["query"]) > 0
            
            # Verify file size is reasonable
            assert full_report["metadata"]["file_size_bytes"] > 0
            
    finally:
        Config.REPORT_OUTPUT_DIR = original_dir


def test_history_pagination_logic(client):
    """Test history pagination with different parameters"""
    # Test with different limit values
    for limit in [5, 10, 20]:
        response = client.get(f"/api/research/history?limit={limit}")
        
        if response.status_code == 200:
            data = response.json()
            assert data["limit"] == limit
            assert len(data["queries"]) <= limit
    
    # Test with offset
    response = client.get("/api/research/history?limit=5&offset=10")
    
    if response.status_code == 200:
        data = response.json()
        assert data["limit"] == 5
        assert data["offset"] == 10


def test_history_filtering_by_relevance(client):
    """Test history filtering by minimum relevance score"""
    # Test with different relevance thresholds
    for min_relevance in [0.0, 0.5, 0.7, 0.9]:
        response = client.get(f"/api/research/history?min_relevance={min_relevance}")
        
        if response.status_code == 200:
            data = response.json()
            
            # Verify all returned queries meet the threshold
            for query in data["queries"]:
                assert query["relevance_score"] >= min_relevance


def test_error_handling_invalid_report_id(client):
    """Test error handling for invalid report IDs"""
    # Test various invalid formats
    invalid_ids = [
        "invalid",
        "report_",
        "report_invalid_date",
        "not_a_report_id"
    ]
    
    for invalid_id in invalid_ids:
        response = client.get(f"/api/reports/{invalid_id}")
        
        # Should return 400 (bad request) or 404 (not found)
        assert response.status_code in [400, 404]
    
    # Empty string is a special case - FastAPI redirects to list endpoint
    response = client.get("/api/reports/", follow_redirects=False)
    assert response.status_code in [307, 308]  # Redirect status codes


def test_concurrent_requests(client, temp_reports_dir):
    """Test handling of concurrent requests to endpoints"""
    original_dir = Config.REPORT_OUTPUT_DIR
    Config.REPORT_OUTPUT_DIR = temp_reports_dir
    
    try:
        # Make multiple concurrent requests
        import concurrent.futures
        
        def make_request(endpoint):
            return client.get(endpoint)
        
        endpoints = [
            "/api/reports",
            "/api/reports",
            "/api/research/history",
            "/api/research/history?limit=5",
        ]
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
            futures = [executor.submit(make_request, ep) for ep in endpoints]
            results = [f.result() for f in concurrent.futures.as_completed(futures)]
        
        # All requests should succeed
        for result in results:
            assert result.status_code in [200, 503]  # 503 if memory store not available
        
    finally:
        Config.REPORT_OUTPUT_DIR = original_dir


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
